var tipuesearch = {"pages": [{'title': 'About', 'text': '課程名稱: 協同產品設計實習 - Collaborative Product Design Practice \n 學員作業網站:\xa0 https://mdecd2025.github.io/hw-41223226-0 \n 學員作業倉儲:\xa0 https://github.com/mdecd2025/hw-41223226-0 \n \n 課程代號: cd2025 \n Teams 線上教學: \n 以 "學號@nfu.edu.tw" 登入 \xa0 https://login.microsoftonline.com/ \xa0 Office 365 \n Teams 團隊代碼:\xa0 p5z4eku \n \n 課程評分: \n Homework (30%) - 每週至少提交兩次與課程進度有關的內容, 完成後填回自評表單 \n Exam (40%) - 建立包含操作流程影片、心得以及提供檔案下載的網頁後填回自評表單 \n Final Report (30%) - 利用網頁內容進行簡報並提交 pdf 格式書面報告, 完成後填回自評表單 \n \n', 'tags': '', 'url': 'About.html'}, {'title': 'repo', 'text': '在更新小組list的程式時，順便做的。( 執行結果 ) \n from browser import html, document\nimport urllib.request\n\n# 設定 URL\nurl = "https://mde.tw/list/2b.txt"\n\n# 讀取網站內容\nresponse = urllib.request.urlopen(url)\ndata = response.read().splitlines()  # 直接讀取並按行分割\n\n# 確保資料存在\nif len(data) > 1:\n    all_stud = data[1:]  # 跳過標題列\n    print("總共有 " + str(len(all_stud)) + " 名學員")\nelse:\n    all_stud = []\n    print("學員名單讀取失敗")\n\n# 找到網頁中的特定位置\nbrython_div1 = document["brython_div1"]\n\n# **動態插入所有學員資料，並為帳號添加超連結**\nfor index, student in enumerate(all_stud, start=1):\n    parts = student.split()  # 用空格分割學號和帳號\n    if len(parts) == 2:\n        student_id, account = parts\n        # 設定學號的超連結\n        account_link = f"https://mdecd2025.github.io/hw-{account.strip()}"\n        # 設定repo的超連結\n        repo_link = f"https://github.com/mdecd2025/hw-{account.strip()}"\n        \n        # 插入學號和帳號的超連結，並加上repo的超連結\n        brython_div1 <= f"{index}. " + html.A(student_id.strip(), href=account_link) + " " \n        brython_div1 <= f"（" + html.A("repo", href=repo_link) + "）"\n        brython_div1 <= html.BR()  # 換行\n    else:\n        print(f"格式錯誤，跳過此行: {student}")\n \n \n \n', 'tags': '', 'url': 'repo.html'}, {'title': 'ipv6', 'text': '任務一: 請用 Brython 寫出在 id="brython_div1" 嵌入 html 連結的程式。 希望各連結能透過 http 協定連結到班上有 66 位學員的靜態網頁。 其中各學員的固定 IPv6 分別為 2001:288:6004:17:fff1:cd25:0000:b001 到 2001:288:6004:17:fff1:cd25:0000:b066, 且使用 port 8000 進行連結. 請寫出此一 Brython 程式。 \n 任務二: 若各學員序號取自 https://mde.tw/cd2025/downloads/w4_2b_index.txt, 且此一資料以空白隔開序號加"." 及學號, 能否修改成以學員的學號作為 html 的標示。 \n 用之前寫的在repo的全班名單程式做修改，更換學號上的超連結來達成任務。( 執行結果 ) \n from browser import html, document\nimport urllib.request\n \n# 設定 URL\nurl = "https://mde.tw/list/2b.txt"\n \n# 讀取網站內容\nresponse = urllib.request.urlopen(url)\ndata = response.read().splitlines()  # 直接讀取並按行分割\n \n# 確保資料存在\nif len(data) > 1:\n    all_stud = data[1:]  # 跳過標題列\n    print("總共有 " + str(len(all_stud)) + " 名學員")\nelse:\n    all_stud = []\n    print("學員名單讀取失敗")\n \n# 找到網頁中的特定位置\nbrython_div1 = document["brython_div1"]\n \n# **動態插入所有學員資料，並為帳號添加超連結**\nfor index, student in enumerate(all_stud, start=1):\n    parts = student.split()  # 用空格分割學號和帳號\n    if len(parts) == 2:\n        student_id, account = parts\n        # 設定學號的超連結（指向靜態網站）\n        account_link = f"http://[2001:288:6004:17:fff1:cd25:0000:b0{index}]:8000/"\n        # 設定repo的超連結\n        repo_link = f"https://github.com/mdecd2025/hw-{account.strip()}"\n         \n        # 插入學號和帳號的超連結，並加上repo的超連結\n        brython_div1 <= f"{index}. " + html.A(student_id.strip(), href=account_link) + " "\n        brython_div1 <= f"（" + html.A("repo", href=repo_link) + "）"\n        brython_div1 <= html.BR()  # 換行\n    else:\n        print(f"格式錯誤，跳過此行: {student}")\n \n', 'tags': '', 'url': 'ipv6.html'}, {'title': 'Tasks', 'text': 'task1 與 task2 任務目的在建立可於近端維護個人作業與協同作業的準備工作: \n \xa0 \xa0 \xa0 task1 (自行製作可攜程式系統) \n \xa0 \xa0 \xa0 task2 (使用 SSH 協定執行作業倉儲的推送) \n task3 與 task4 則為 HW2 的內容之一 \n \xa0 \xa0 \xa0 task3 (使用 Solvespace 建立平面四連桿系統零組件) \n \xa0 \xa0 \xa0 task4 (使用 Onshape 建立平面四連桿系統零組件) \n task5 與 task6 則為 HW3 的主要內容 \n \xa0 \xa0 \xa0 task5 (Webots Tutorial 1 ~3) \n \xa0 \xa0 \xa0 task6 (Webots Tutorial 4 ~6) \n', 'tags': '', 'url': 'Tasks.html'}, {'title': 'task1', 'text': '2025/2/25 \n \n', 'tags': '', 'url': 'task1.html'}, {'title': 'list', 'text': '初版:能夠初步完成功能但不夠完善。( 執行結果 ) \n from browser import html, document\nimport urllib.request\n\n# 設定 URL\nurl = "https://mde.tw/list/2b.txt"\n\n# 讀取網站內容\nresponse = urllib.request.urlopen(url)\ndata = response.read().splitlines()  # 直接讀取並按行分割\n\n# 確保資料存在\nif len(data) > 1:\n    all_stud = data[1:]  # 跳過標題列\n    print("總共有 " + str(len(all_stud)) + " 名學員")\nelse:\n    all_stud = []\n    print("學員名單讀取失敗")\n\n# 找到網頁中的特定位置\nbrython_div1 = document["brython_div1"]\n\n# **動態插入所有學員資料，並為帳號添加超連結**\nfor index, student in enumerate(all_stud, start=1):\n    parts = student.split()  # 用空格分割學號和帳號\n    if len(parts) == 2:\n        student_id, account = parts\n        # 設定超連結\n        account_link = f"https://mdecd2025.github.io/hw-{account.strip()}"\n        # 插入學號和帳號的超連結\n        brython_div1 <= f"{index}. {student_id.strip()} - " + html.A(account.strip(), href=account_link)\n        brython_div1 <= html.BR()  # 換行\n    else:\n        print(f"格式錯誤，跳過此行: {student}")\n\n# 測試固定超連結\nbrython_div1 <= html.BR()\nbrython_div1 <= "附加連結: " + html.A("github.com", href="https://github.com")\n \n \n 完成版:這版具有完整功能，並且能夠顯示我們全部組員的倉儲和網站。( 執行結果 ) \n from browser import html, document\nimport urllib.request\n\n# 設定 URL\nurl = "https://mde.tw/list/2b.txt"\n\n# 讀取網站內容\nresponse = urllib.request.urlopen(url)\ndata = response.read().splitlines()  # 直接讀取並按行分割\n\n# 確保資料存在\nif len(data) > 1:\n    all_stud = data[1:]  # 跳過標題列\n    print("總共有 " + str(len(all_stud)) + " 名學員")\nelse:\n    all_stud = []\n    print("學員名單讀取失敗")\n\n# G3組的學員學號列表\ng3_students = [\'41223206\', \'41223215\', \'41223226\', \'41223227\', \'41223228\', \'41223235\']\n\n# 找到網頁中的特定位置\nbrython_div1 = document["brython_div1"]\n\n# **動態插入 G3 組的學員資料，並為帳號添加超連結**\nfor index, student in enumerate(all_stud, start=1):\n    parts = student.split()  # 用空格分割學號和帳號\n    if len(parts) == 2:\n        student_id, account = parts\n        if student_id in g3_students:  # 只顯示G3組的學員\n            # 設定學號的超連結\n            account_link = f"https://mdecd2025.github.io/hw-{account.strip()}"\n            # 設定repo的超連結\n            repo_link = f"https://github.com/mdecd2025/hw-{account.strip()}"\n            \n            # 插入學號和帳號的超連結，並加上repo的超連結\n            brython_div1 <= f"{index}. " + html.A(student_id.strip(), href=account_link) + " " \n            brython_div1 <= f"（" + html.A("repo", href=repo_link) + "）"\n            brython_div1 <= html.BR()  # 換行\n    else:\n        print(f"格式錯誤，跳過此行: {student}") \n \n \n \n \n \n', 'tags': '', 'url': 'list.html'}, {'title': 'task2', 'text': '2025/2/25 \n \n', 'tags': '', 'url': 'task2.html'}, {'title': 'w3', 'text': '已知各班已經參與分組的學員 Github 帳號分別如下: \n a_all_members = [\'41223154\', \'41271125\', \'41271158\', \'41271146\', \'41271131\', \'CYG41223103\', \'41223102\', \'41023128\', \'41023137\', \'41223137\', \'41223157\', \'41223156\', \'otakuyoyo\', \'41223141\', \'41223113\', \'kim41223114\', \'joeisme1208\', \'41223116\', \'41223144\', \'41223140\', \'41223143\', \'41223138\', \'41223134\', \'41223136\', \'zhe41223118\', \'Spirit0224\', \'yuhao-08\', \'41223158\', \'Ren911308\', \'41223150\', \'Manto8\', \'CYA41223106\', \'yan21ed\', \'Lin41223107\', \'41223133\', \'hong41223129\', \'41223110\', \'41223147\', \'Linjiahong41223125\', \'CHN41223132\', \'Yu-Fang-Hong\', \'41023111\', \'yckaooooo\', \'kolas911205\', \'41023105\', \'40932134\', \'41223104\', \'yan41223101\', \'41223105\', \'41223153\', \'41223120\', \'41223152\', \'G8People\', \'WSE41223112\', \'41223146\', \'41223119\']\nb_all_members = [\'41223251\', \'41223211\', \'41223245\', \'41223243\', \'jjjay41223212\', \'leeshaowei0716\', \'41223234\', \'41223209\', \'41223205\', \'41223201\', \'41223202\', \'41223208-hw\', \'41223216\', \'41223217\', \'41223248\', \'emma0312\', \'41223242\', \'41223203\', \'41223144\', \'41223235\', \'RAY41223215\', \'hyy41223228\', \'41223227\', \'41223206\', \'41223226-0\', \'Cloud41223237\', \'Yujenchuang\', \'41223225\', \'ljg41223220\', \'supowen\', \'jacky93111\', \'41223246\', \'Liu41223244\', \'41223236\', \'41223219\', \'41271237\', \'41223249\', \'41223229\', \'41223224\', \'41223222\', \'41223231\', \'linryan23\', \'41023114\', \'41223230\', \'timluo123\', \'CYC41223247\', \'41223218\', \'ych0227\', \'41023215\', \'41023216\', \'41023213\', \'41071203\', \'41071204\', \'41071202\', \'c-ching\', \'YUN4\', \'tseYU000\', \'snowfall-killer\', \'junpig10\'] \n 接著用程式列出目前各班尚未納組的學員學號。( 執行結果 ) \n from browser import html, document\nimport urllib.request\n\n# 設定 URL\nurl = "https://mde.tw/list/2b.txt"\n\n# 讀取網站內容\nresponse = urllib.request.urlopen(url)\ndata = response.read().splitlines()  # 直接讀取並按行分割\n\n# 確保資料存在\nif len(data) > 1:\n    all_stud = data[1:]  # 跳過標題列\n    print("總共有 " + str(len(all_stud)) + " 名學員")\nelse:\n    all_stud = []\n    print("學員名單讀取失敗")\n\n# 已分組的帳號名單\ngrouped_accounts = {\n    \'41223251\', \'41223211\', \'41223245\', \'41223243\', \'jjjay41223212\', \'leeshaowei0716\', \n    \'41223234\', \'41223209\', \'41223205\', \'41223201\', \'41223202\', \'41223208-hw\', \'41223216\', \n    \'41223217\', \'41223248\', \'emma0312\', \'41223242\', \'41223203\', \'41223144\', \'41223235\', \n    \'RAY41223215\', \'hyy41223228\', \'41223227\', \'41223206\', \'41223226-0\', \'Cloud41223237\', \n    \'Yujenchuang\', \'41223225\', \'ljg41223220\', \'supowen\', \'jacky93111\', \'41223246\', \'Liu41223244\', \n    \'41223236\', \'41223219\', \'41271237\', \'41223249\', \'41223229\', \'41223224\', \'41223222\', \n    \'41223231\', \'linryan23\', \'41023114\', \'41223230\', \'timluo123\', \'CYC41223247\', \'41223218\', \n    \'ych0227\', \'41023215\', \'41023216\', \'41023213\', \'41071203\', \'41071204\', \'41071202\', \n    \'c-ching\', \'YUN4\', \'tseYU000\', \'snowfall-killer\', \'junpig10\'\n}\n\n# 找到網頁中的特定位置\nbrython_div1 = document["brython_div1"]\n\n# **動態插入未分組的學號與超連結**\nindex = 1\nfor student in all_stud:\n    parts = student.strip().split()  # 用空格分割\n    if len(parts) == 0:\n        continue  # 跳過空行\n    \n    student_id = parts[0]  # 學號\n    account = parts[1] if len(parts) > 1 else student_id  # 若帳號空白則用學號當帳號\n\n    if account not in grouped_accounts:  # 只處理未分組帳號\n        # 設定學號的超連結\n        student_link = f"https://mdecd2025.github.io/hw-{account}"\n        # 設定repo的超連結\n        repo_link = f"https://github.com/mdecd2025/hw-{account}"\n        \n        # 插入學號作為超連結，並添加 repo 連結\n        brython_div1 <= f"{index}. " + html.A(student_id, href=student_link) + " "\n        brython_div1 <= f"（" + html.A("repo", href=repo_link) + "）"\n        brython_div1 <= html.BR()  # 換行\n        index += 1 \n \n \n', 'tags': '', 'url': 'w3.html'}, {'title': 'task3', 'text': '使用 Solvespace 建立平面四連桿系統零組件', 'tags': '', 'url': 'task3.html'}, {'title': 'task4', 'text': '', 'tags': '', 'url': 'task4.html'}, {'title': 'task5', 'text': 'Webots Tutorial 1 ~3 \n 檔案下載 \n', 'tags': '', 'url': 'task5.html'}, {'title': 'task6', 'text': 'Webots Tutorial 4 ~6 \n 檔案下載 \n', 'tags': '', 'url': 'task6.html'}, {'title': 'Homework', 'text': '作業 (30%) \n HW1 (5%):  建立由 Box 組成的平面四連桿機構 Webots 模擬場景 \n part1: \n 請各學員在 USB 隨身碟或個人電腦上完成 cd2025 課程所需的可攜系統配置: \n 下載  portable_wcm2025.7z  (330MB, 解開壓縮後 1.4GB) \n Webots_2025a.7z  (1.5 GB, 解開後約為 2.9GB, 可單獨運作) \n Webots_2025a_web.7z  (171 MB, 解開壓縮後約為 1GB, 必須連網運作) \n Blender4.2.7z \n part2: \n 請各學員完成可攜程式系統配置後, 利用 Webots R2025a 中寬度與高度都為 0.1m 的 box 物件建立一個簡單的平面四連桿機構模擬場景. \n base (基座) 長度 1m, link1 長度 0.4m, link2 長度 0.6m, link3 長度 0.9m, 各轉軸均為 HingeJoint, joint1 旋轉速度設定為 1radian/sec. \n part3: \n 模擬場景啟動後, 按下 s 鍵機構開始作動, 按下 p 鍵後機構暫停. \n 參考資料: \n cd2025_hw1_demo.7z \n HW2 (5%):  建立由 CAD 繪製零件組成的平面四連桿機構 Webots 模擬場景 \n 各學員請利用 CAD 系統依據 HW1 的連桿尺寸與運動方式, 配置適當大小的旋轉軸以及基座後, 利用 Webots R2025a 完成一個簡單的平面四連桿機構模擬場景. \n 參考資料: \n fourbar_slvs.7z \n HW3 (20%): 建立 Webots 桌上籃球遊戲機模擬系統 \n 請各分組利用CAD 系統建立一個能在電腦桌 (1600W X 700D X 740H mm) 上運作的投籃機構 ( 參考影片 )後, 導入 Webots R2025a 套件, 建立一個能由使用者透過鍵盤按鍵操作, 且具備計分板的籃球遊戲機模擬系統. \n 參考資料: \n 參考資料: \n fourbar_ball_throwing_linkage.slvs \n sixbar_ball_throwing_linkage.slvs \n \n', 'tags': '', 'url': 'Homework.html'}, {'title': 'HW1', 'text': 'HW1 (5%):  建立由 Box 組成的平面四連桿機構 Webots 模擬場景 \n 操作影片標題: 國立虎尾科技大學 - 機械設計工程系 - cd2025 HW1 - 41223226 \n 先由solvespace畫簡單的模型模擬旋轉路徑，然後再開始使用Webots進行模型的建立。 \n fourbar_box_41223226 \n \n', 'tags': '', 'url': 'HW1.html'}, {'title': 'HW2', 'text': 'HW2 (5%):  建立由 CAD 繪製零件組成的平面四連桿機構 Webots 模擬場景 \n 操作影片標題: 國立虎尾科技大學 - 機械設計工程系 - cd2025 HW2 - 41223226 \n 用 solvespace畫複雜的模型，然後再使用Blender進行模型的拆分和轉檔，最後在使用HW1的程式將之前建立的簡單模型改為調用拆解好的複雜模型，即可運轉。 \n fourbar_box2_41223226 \n', 'tags': '', 'url': 'HW2.html'}, {'title': 'HW3', 'text': 'HW3 (20%): 建立 Webots 桌上籃球遊戲機模擬系統 \n 操作影片標題: 國立虎尾科技大學 - 機械設計工程系 - cd2025 HW3 - 41223226 \n 從base開始一步一步堆疊關節和零件最後在建立場景。 \n \n Webots 桌上籃球遊戲機模擬系統 \n', 'tags': '', 'url': 'HW3.html'}, {'title': 'Midterm', 'text': '本課程所繳交的期中成績為學員自評之學習期望成績. \n 期中考週的自評期望成績繳交流程: \n \n 整理先前所完成的各週的進度、作業網頁內容以及心得 \n 拍攝期中自評影片, 上傳至 Youtube 後, 以" 國立虎尾科技大學 - 機械設計工程系 - cd2025 期中自評- 學員學號 "為影片標題後嵌入本頁面中 \n 回填期中自評表單 \n 上傳學員期中成績 \n \n 各週進度:各週按時更新，完成了跟list相關的全部程式，完成 Webots Tutorial 1~6 完成HW1 四連桿的組立和運轉。 \n 各週網頁內容: \n 全班 list \n ipv6 list \n 小組 list \n 未分組名單 list \n Webots Tutorial 1~3 \n Webots Tutorial 4~6 \n HW1 \n 期中心得: \n 這半個學期學到了很多關於list的程式，學到了節省算力的概念，能用更簡單的方式達成，就不要用複雜的方法，還大致上學會了Webots要如何使用，光是這幾週就讓我受益良多，希望能夠在更深入的了解。 \n 期中自評影片: \n \n', 'tags': '', 'url': 'Midterm.html'}, {'title': 'Exam', 'text': 'Exam1 (10%): 建立 Webots 基本物件模擬場景 \n 各學員利用 Webots R2025a 套件中的 Shape 物件, 隨堂建立指定的機電系統模擬場景, 並利用 Python 程式進行互動控制. \n Exam2 (10%): 利用 CAD 零組件建立模擬場景\xa0 \n 各學員利用 CAD (Solvespace 與 NX2312), 隨堂建立指定的系統模型零組件後, 導入 Webots R2025a 後, 建立機電系統模擬場景, 並利用 Python 程式進行互動控制. \n Exam3 (20%): Webots 機電模擬場景的協同設計 \n 各分組利用 CAD (Solvespace 與 NX2312), 隨堂建立指定的系統模型零組件後, 導入 Webots R2025a 後, 建立機電系統模擬場景, 並利用 Python 程式進行互動控制. 過程中各學員必須採同步協同模式, 維護從 Github Classroom 取得的分組協同倉儲以及網站. \n 協同分組方式: \n \n 分配學員負責利用 Solvespace 建立系統零組件, 過程中必須將所建構之零組件檔案與繪圖過程影片上傳至分組網頁. \n 分配學員負責利用 NX2312 建立系統零組件, 過程中必須將所建構之零組件檔案與繪圖過程影片上傳至分組網頁. \n 分配學員負責利用 Webots 建立機電系統模擬場景, 並利用 Python 程式進行控制, 過程中必須將建構過程拍成帶有說明字幕的影片上傳至分組網頁. \n \n', 'tags': '', 'url': 'Exam.html'}, {'title': 'Exam1', 'text': 'Exam1 (10%): 建立 Webots 基本物件模擬場景 \n 操作影片標題: 國立虎尾科技大學 - 機械設計工程系 - cd2025 Exam1 -\xa041223226 \n Exam1 \n', 'tags': '', 'url': 'Exam1.html'}, {'title': 'Exam2', 'text': 'Exam2 (10%): 利用 CAD 零組件建立模擬場景 \n 操作影片標題: 國立虎尾科技大學 - 機械設計工程系 - cd2025 Exam2 - 41223226 \n Exam2 \n', 'tags': '', 'url': 'Exam2.html'}, {'title': 'Exam3', 'text': 'Exam3 (20%): Webots 機電模擬場景的協同設計 \n 操作影片標題: 國立虎尾科技大學 - 機械設計工程系 - cd2025 Exam3 - 學員學號 \n', 'tags': '', 'url': 'Exam3.html'}, {'title': 'Final', 'text': '期末協同專案執行過程影片、簡報與 PDf 報告檔案 (六人一組) (30%) \n 題目: Webots 動態投籃模擬系統的協同設計 \n 說明:  \n 籃框架被配置在一定範圍內, 可隨機慢速前進、後退及左右擺動, 投籃機構系統帶有一定數量的籃球, 被配置在可自由移動的輪車上. \n 操作者可利用鍵盤特定按鍵控制投籃輪車的移動並發射投籃, 每投出一球後系統透過記分板進行計分, 並由送球機構進行補球或移動輪車取球, 遊戲可進行至全部數量籃球投完為止. \n 請將期末協同專案執行過程、內容與心得, 製作成影片，配合字幕上傳至 Youtube 後嵌入各階段的期末報告頁面中. \n Webots 動態投籃模擬系統的協同設計_第三組_報告.pdf \n Webots 動態投籃模擬系統的協同設計_第三組_簡報 \n \n fourbar_controller.py \n from controller import Robot, Keyboard\nimport time\n\n# 常數定義\nTIME_STEP = 32  # 模擬步長，單位毫秒\nMAX_VELOCITY = 10.0  # 輪子的最大速度\nANGLE_STEP = 40 * 3.14159 / 180  # 40 度轉為弧度，作為擊球角度\nPOSITION_M = ANGLE_STEP          # motor 擊出角度（+40度）\nPOSITION_K = 0.0                 # motor 收回角度（0度）\nKICK_DELAY = 0.5                 # 擊出後等待時間（秒）\n\n# 初始化機器人與鍵盤控制\nrobot = Robot()\ntimestep = int(robot.getBasicTimeStep())\nkeyboard = Keyboard()\nkeyboard.enable(timestep)  # 啟用鍵盤事件監聽\n\n# 嘗試取得 motor 與對應的感測器\ntry:\n    motor = robot.getDevice(\'motor1\')  # 擊球機構用的伺服馬達\n    sensor = robot.getDevice(\'motor1_sensor\')  # 馬達的位置感測器\n    sensor.enable(timestep)\n    mechanism_enabled = True  # 如果取得成功，表示擊球裝置可用\nexcept Exception:\n    mechanism_enabled = False  # 否則關閉機構功能\n\n# 嘗試取得輪子馬達（移動平台）\ntry:\n    wheels = [robot.getDevice(f"wheel{i+1}") for i in range(4)]  # 四個輪子馬達\n    for wheel in wheels:\n        wheel.setPosition(float(\'inf\'))  # 設定為速度控制模式（非位置控制）\n        wheel.setVelocity(0)  # 初始速度為 0\n    platform_enabled = True  # 若成功取得，表示移動平台可用\nexcept Exception:\n    platform_enabled = False\n\n# 用來避免重複偵測按鍵（去彈跳）\nkey_pressed = {\n    \'k\': False\n}\n\n# 主循環\nwhile robot.step(timestep) != -1:\n    key = keyboard.getKey()  # 讀取目前按下的按鍵\n\n    # 平台移動控制（如果有輪子）\n    if platform_enabled:\n        if key == Keyboard.UP:\n            # 向前\n            for wheel in wheels:\n                wheel.setVelocity(MAX_VELOCITY)\n        elif key == Keyboard.DOWN:\n            # 向後\n            for wheel in wheels:\n                wheel.setVelocity(-MAX_VELOCITY)\n        elif key == Keyboard.LEFT:\n            # 左轉（右輪正轉，左輪反轉）\n            wheels[0].setVelocity(MAX_VELOCITY)\n            wheels[1].setVelocity(-MAX_VELOCITY)\n            wheels[2].setVelocity(MAX_VELOCITY)\n            wheels[3].setVelocity(-MAX_VELOCITY)\n        elif key == Keyboard.RIGHT:\n            # 右轉（左輪正轉，右輪反轉）\n            wheels[0].setVelocity(-MAX_VELOCITY)\n            wheels[1].setVelocity(MAX_VELOCITY)\n            wheels[2].setVelocity(-MAX_VELOCITY)\n            wheels[3].setVelocity(MAX_VELOCITY)\n        elif key == ord(\'Q\') or key == ord(\'q\'):\n            # 按 Q 鍵退出程式\n            print("Exiting...")\n            break\n        else:\n            # 沒有按方向鍵時停止移動\n            for wheel in wheels:\n                wheel.setVelocity(0)\n\n    # 擊球機構控制（如果有 motor）\n    if mechanism_enabled:\n        if key == ord(\'M\') or key == ord(\'k\'):\n            if not key_pressed[\'M\']:\n                print("[KICK] 出擊 → 收回")\n                motor.setPosition(POSITION_M)  # 設定擊球角度（出擊）\n\n                # 非阻塞式等待 0.5 秒（等待擊球完成）\n                start_time = robot.getTime()\n                while robot.step(timestep) != -1:\n                    if robot.getTime() - start_time >= KICK_DELAY:\n                        break\n\n                motor.setPosition(POSITION_K)  # 收回擊球機構\n            key_pressed[\'M\'] = True  # 記錄已按下\n        else:\n            key_pressed[\'M\'] = False  # 沒有按鍵，重設狀態\n \n feed_ball.py \n from controller import Supervisor, Keyboard\nimport time\nimport random\nimport numpy as np\nimport re\n\nclass BallManager:\n    # 球體半徑\n    SPHERE_RADIUS = 0.1\n    # 軌跡點半徑\n    TRAJECTORY_POINT_RADIUS = 0.03\n    # 軌跡點距離間隔\n    TRAJECTORY_POINT_STEP = 0.12\n    # 軌跡點最大數量\n    TRAJECTORY_MAX_POINTS = 5\n    # 按鍵去彈跳時間(秒)\n    DEBOUNCE_TIME = 0.5\n    # 印出位置資訊間隔(秒)\n    PRINT_INTERVAL = 0.2\n    # 球落地判斷閾值(z軸高度)\n    LANDING_THRESHOLD_Z = 0.13\n\n    def __init__(self, supervisor: Supervisor):\n        self.supervisor = supervisor\n        self.timestep = int(supervisor.getBasicTimeStep())\n        self.keyboard = Keyboard()\n        self.keyboard.enable(self.timestep)  # 啟用鍵盤偵測\n\n        # 等待擊出的靜止球的 DEF 名稱和資訊\n        self.waiting_ball_def = None\n        self.waiting_ball_info = None\n\n        self.last_key_time = 0  # 上次按鍵時間(用於去彈跳)\n        self.last_print_time = 0  # 上次印出位置時間\n\n        self.trajectory_points = []  # 軌跡點列表，存 (位置, DEF 名稱)\n        self.current_tracked_def = None  # 目前追蹤的球 DEF 名稱\n\n        # 取得 youbot 節點，用來做座標轉換\n        self.youbot_node = supervisor.getFromDef(\'youbot\')\n        if self.youbot_node is None:\n            raise RuntimeError("找不到 DEF 為 youbot 的 Robot 物件")\n\n        # 球產生的本地位置 (相對 youbot)\n        self.default_feed_pos = (-0.35, 0.0, 0.9)\n\n        # 用來匹配球 DEF 名稱的正則表達式（目前未用，但可擴充）\n        self.ball_def_pattern = re.compile(r"Sphere_\\d+")\n\n    def axis_angle_to_rotation_matrix(self, axis, angle):\n        # 將軸角旋轉轉成 3x3 旋轉矩陣 (numpy陣列)\n        x, y, z = axis\n        c = np.cos(angle)\n        s = np.sin(angle)\n        C = 1 - c\n        return np.array([\n            [x*x*C + c,   x*y*C - z*s, x*z*C + y*s],\n            [y*x*C + z*s, y*y*C + c,   y*z*C - x*s],\n            [z*x*C - y*s, z*y*C + x*s, z*z*C + c]\n        ])\n\n    def generate_valid_def_name(self, base_name="Sphere"):\n        # 產生唯一的 DEF 名稱，防止重複衝突\n        timestamp = int(self.supervisor.getTime() * 1000)\n        return f"{base_name}_{timestamp}_{random.randint(0, 10000)}"\n\n    def generate_random_color(self):\n        # 隨機產生 RGB 三色(0~1之間浮點數)\n        return random.random(), random.random(), random.random()\n\n    def youbot_local_to_world(self, local_pos):\n        # 將 youbot 本地座標轉換成世界座標\n        youbot_translation = np.array(self.youbot_node.getField(\'translation\').getSFVec3f())\n        youbot_rotation = self.youbot_node.getField(\'rotation\').getSFRotation()\n        axis = youbot_rotation[:3]\n        angle = youbot_rotation[3]\n        rot_mat = self.axis_angle_to_rotation_matrix(axis, angle)\n        rotated = rot_mat @ np.array(local_pos)\n        world_pos = youbot_translation + rotated\n        return tuple(world_pos)\n\n    def create_static_ball(self, def_name, world_pos, r, g, b):\n        # 在世界中產生靜止的球\n        sphere_str = f"""\n        DEF {def_name} Solid {{\n          translation {world_pos[0]} {world_pos[1]} {world_pos[2]}\n          contactMaterial "ball"\n          children [\n            Shape {{\n              geometry Sphere {{\n                radius {self.SPHERE_RADIUS}\n              }}\n              appearance Appearance {{\n                material Material {{\n                  diffuseColor {r} {g} {b}\n                }}\n              }}\n            }}\n          ]\n          boundingObject Sphere {{\n            radius {self.SPHERE_RADIUS}\n          }}\n        }}\n        """\n        self.supervisor.getRoot().getField("children").importMFNodeFromString(-1, sphere_str)\n\n    def create_dynamic_ball(self, def_name, world_pos, r, g, b):\n        # 在世界中產生可動態物理的球（可被擊出）\n        sphere_str = f"""\n        DEF {def_name} Solid {{\n          translation {world_pos[0]} {world_pos[1]} {world_pos[2]}\n          contactMaterial "ball"\n          children [\n            Shape {{\n              geometry Sphere {{\n                radius {self.SPHERE_RADIUS}\n              }}\n              appearance Appearance {{\n                material Material {{\n                  diffuseColor {r} {g} {b}\n                }}\n              }}\n            }}\n          ]\n          boundingObject Sphere {{\n            radius {self.SPHERE_RADIUS}\n          }}\n          physics Physics {{\n            mass 0.01\n            density -1\n          }}\n        }}\n        """\n        self.supervisor.getRoot().getField("children").importMFNodeFromString(-1, sphere_str)\n\n    def create_trajectory_point(self, pos):\n        # 建立一個透明橘色小球作為軌跡點\n        def_name = self.generate_valid_def_name("TrajectoryPt")\n        sphere_str = f"""\n        DEF {def_name} Transform {{\n          translation {pos[0]} {pos[1]} {pos[2]}\n          children [\n            Shape {{\n              geometry Sphere {{\n                radius {self.TRAJECTORY_POINT_RADIUS}\n              }}\n              appearance Appearance {{\n                material Material {{\n                  diffuseColor 1 0.7 0\n                  transparency 0.3\n                }}\n              }}\n            }}\n          ]\n        }}\n        """\n        self.supervisor.getRoot().getField("children").importMFNodeFromString(-1, sphere_str)\n        return def_name\n\n    def delete_trajectory_points(self):\n        # 刪除所有軌跡點物件\n        for _, def_name in self.trajectory_points:\n            node = self.supervisor.getFromDef(def_name)\n            if node:\n                node.remove()\n        self.trajectory_points.clear()\n\n    def create_static_sphere(self, x, y, z):\n        # 嘗試產生一顆靜止球\n        if self.waiting_ball_def is not None:\n            print("還有一顆球等待擊出，請先擊出再產生新球。")\n            return False\n        def_name = self.generate_valid_def_name()\n        world_pos = self.youbot_local_to_world((x, y, z))\n        r, g, b = self.generate_random_color()\n        self.waiting_ball_def = def_name\n        self.waiting_ball_info = (world_pos, r, g, b)\n        self.create_static_ball(def_name, world_pos, r, g, b)\n        self.current_tracked_def = def_name\n        self.delete_trajectory_points()  # 新球產生，清除舊軌跡點\n        print(f"已產生靜止球 {def_name} 於 {world_pos}")\n        return True\n\n    def activate_dynamic_ball(self):\n        # 將等待的靜止球刪除並重新產生為動態球（可被擊出）\n        if self.waiting_ball_def is None or self.waiting_ball_info is None:\n            print("沒有等待擊出的球。")\n            return False\n        ball_node = self.supervisor.getFromDef(self.waiting_ball_def)\n        if ball_node:\n            ball_node.remove()\n            self.supervisor.step(self.timestep)  # 等待場景更新\n        world_pos, r, g, b = self.waiting_ball_info\n        self.create_dynamic_ball(self.waiting_ball_def, world_pos, r, g, b)\n        print(f"球 {self.waiting_ball_def} 變成動態球")\n        self.waiting_ball_def = None\n        self.waiting_ball_info = None\n        return True\n\n    def is_ball_landed(self, pos):\n        # 判斷球是否已落地(根據 z 軸高度)\n        return pos[2] < self.LANDING_THRESHOLD_Z\n\n    def run(self):\n        # 主程式迴圈，處理按鍵與軌跡追蹤\n        print("按 A 產生一顆靜止球，按 M 讓球變 dynamic 可擊出")\n        while self.supervisor.step(self.timestep) != -1:\n            key = self.keyboard.getKey()\n            current_time = time.time()\n\n            # 按鍵去彈跳判斷\n            if key != -1 and (current_time - self.last_key_time < self.DEBOUNCE_TIME):\n                key = -1\n\n            if key == ord(\'A\'):\n                # 按 A 產生靜止球\n                if self.create_static_sphere(*self.default_feed_pos):\n                    self.last_key_time = current_time\n\n            elif key == ord(\'M\'):\n                # 按 M 使球成為動態球\n                if self.activate_dynamic_ball():\n                    self.last_key_time = current_time\n\n            # 軌跡點追蹤\n            if self.current_tracked_def:\n                ball_node = self.supervisor.getFromDef(self.current_tracked_def)\n                if ball_node:\n                    pos = ball_node.getPosition()\n                    # 定時印出位置資訊\n                    if current_time - self.last_print_time >= self.PRINT_INTERVAL:\n                        print(f"球 {self.current_tracked_def} 位置: [{pos[0]:.4f}, {pos[1]:.4f}, {pos[2]:.4f}]")\n                        self.last_print_time = current_time\n\n                    # 如果球移動超過軌跡間距，新增軌跡點\n                    if (not self.trajectory_points) or np.linalg.norm(np.array(pos) - np.array(self.trajectory_points[-1][0])) > self.TRAJECTORY_POINT_STEP:\n                        def_name = self.create_trajectory_point(pos)\n                        self.trajectory_points.append((pos, def_name))\n                        # 軌跡點數量超過限制，刪除最舊的\n                        if len(self.trajectory_points) > self.TRAJECTORY_MAX_POINTS:\n                            _, old_def = self.trajectory_points.pop(0)\n                            old_node = self.supervisor.getFromDef(old_def)\n                            if old_node:\n                                old_node.remove()\n\n                    # 球落地，清除軌跡點\n                    if self.is_ball_landed(pos):\n                        self.delete_trajectory_points()\n                else:\n                    # 找不到球，清除軌跡並停止追蹤\n                    self.delete_trajectory_points()\n                    self.current_tracked_def = None\n\nif __name__ == "__main__":\n    supervisor = Supervisor()\n    ball_manager = BallManager(supervisor)\n    ball_manager.run() \n basket.py \n from controller import Robot, Keyboard, Emitter  # 匯入 Webots 控制所需的模組\n\n# 常數設定\nWHEEL_RADIUS = 0.1  # 輪子半徑（單位：公尺）\nL = 0.471  # 機器人長度的一半（用於運動學計算）\nW = 0.376  # 機器人寬度的一半\nMAX_VELOCITY = 10.0  # 輪子最大速度\n\n# 初始化機器人與鍵盤\nrobot = Robot()\ntimestep = int(robot.getBasicTimeStep())  # 取得模擬的時間步長\nkeyboard = Keyboard()\nkeyboard.enable(timestep)  # 啟用鍵盤控制\n\n# 取得發射器裝置，用來傳送得分\nemitter = robot.getDevice("score_emitter")\n\n# 取得距離感測器裝置\nsensor = robot.getDevice(\'sensor\')\nsensor.enable(timestep)  # 啟用感測器\nscore = 0  # 初始得分為 0\nlast_score_time = 0  # 上一次得分的時間\ncooldown = 1.0  # 冷卻時間（秒）\n\n# 取得四個輪子的馬達裝置\nwheel5 = robot.getDevice("wheel5")  # 右前輪\nwheel6 = robot.getDevice("wheel6")  # 左前輪\nwheel7 = robot.getDevice("wheel7")  # 右後輪\nwheel8 = robot.getDevice("wheel8")  # 左後輪\n\n# 啟用速度控制模式（無限位置）\nfor wheel in [wheel5, wheel6, wheel7, wheel8]:\n    wheel.setPosition(float(\'inf\'))  # 設定馬達為無限轉動模式\n    wheel.setVelocity(0)  # 初始速度為 0\n\n# 設定四個輪子的速度\ndef set_wheel_velocity(v1, v2, v3, v4):\n    wheel5.setVelocity(v1)\n    wheel6.setVelocity(v2)\n    wheel7.setVelocity(v3)\n    wheel8.setVelocity(v4)\n\n# A/D 轉換值對應距離的查表（模擬非線性感測器）\nlookup_table = [\n    (1000, 0.00),\n    (620, 0.12),\n    (372, 0.13),\n    (248, 0.14),\n    (186, 0.15),\n    (0, 0.18)\n]\n\n# 將感測器讀到的 AD 值轉換為距離（內插法）\ndef ad_to_distance(ad_value):\n    for i in range(len(lookup_table) - 1):\n        a0, d0 = lookup_table[i]\n        a1, d1 = lookup_table[i + 1]\n        if a1 <= ad_value <= a0:\n            return d0 + (d1 - d0) * (ad_value - a0) / (a1 - a0)\n    if ad_value > lookup_table[0][0]:\n        return lookup_table[0][1]  # 超出最大值時回傳最小距離\n    return lookup_table[-1][1]  # 小於最小 AD 值時回傳最大距離\n\n# 顯示操作說明\nprint("Controls:")\nprint("U = forward, J = backward, H = turn left, K = turn right, Q = quit")\n\n# 主迴圈\nkeys = set()\nwhile robot.step(timestep) != -1:\n    key = keyboard.getKey()  # 讀取按鍵輸入\n    while key != -1:\n        keys.add(key)\n        key = keyboard.getKey()\n\n    # 取得感測器數值並轉換為距離\n    sensor_value = sensor.getValue()\n    distance = ad_to_distance(sensor_value)\n    current_time = robot.getTime()\n\n    # 如果按下 M 或 K，顯示目前距離\n    if ord(\'M\') in keys or ord(\'m\') in keys:\n        print("Distance (M):", distance)\n    if ord(\'K\') in keys or ord(\'k\') in keys:\n        print("Distance (K):", distance)\n\n    # 如果距離小於 0.18 且符合冷卻時間，則得分 +2\n    if distance < 0.18 and (current_time - last_score_time) > cooldown:\n        score += 2\n        last_score_time = current_time\n        print("得分 +2")\n        print("Current Distance:", distance)\n        emitter.send(str(2))  # 傳送得分資料給其他模組或使用者介面\n\n    # 控制移動\n    if ord(\'U\') in keys or ord(\'u\') in keys:\n        # 前進\n        set_wheel_velocity(MAX_VELOCITY, MAX_VELOCITY, MAX_VELOCITY, MAX_VELOCITY)\n    elif ord(\'J\') in keys or ord(\'j\') in keys:\n        # 後退\n        set_wheel_velocity(-MAX_VELOCITY, -MAX_VELOCITY, -MAX_VELOCITY, -MAX_VELOCITY)\n    elif ord(\'K\') in keys or ord(\'k\') in keys:\n        # 向右轉（右輪倒轉，左輪前進）\n        set_wheel_velocity(-MAX_VELOCITY, MAX_VELOCITY, -MAX_VELOCITY, MAX_VELOCITY)\n    elif ord(\'H\') in keys or ord(\'h\') in keys:\n        # 向左轉（左輪倒轉，右輪前進）\n        set_wheel_velocity(MAX_VELOCITY, -MAX_VELOCITY, MAX_VELOCITY, -MAX_VELOCITY)\n    elif ord(\'Q\') in keys or ord(\'q\') in keys:\n        # 結束程式\n        print("Exiting...")\n        break\n    else:\n        # 沒有按任何鍵時停止\n        set_wheel_velocity(0, 0, 0, 0)\n\n    keys.clear()  # 清除本次讀取的按鍵 \n Final_Project \n 心得: \n 這次的專案我負責了三個主要程式：fourbar_controller.py、feed_ball.py 以及 stand_controller.py。透過這些程式，我深入了解了機械四連桿機構的控制邏輯與實作方式，以及機器人自動化執行任務的流程。 \n 在 fourbar_controller.py 中，我學會如何運用程式來調整四連桿的位置，精確調整各關節的角度，使機構能穩定且連續地執行動作。feed_ball.py 則讓我體會到自動化流程中，如何設計餵球機制，包含感測器偵測與馬達驅動的配合，確保物料能順利送達。 \n 整體而言，這次專案讓我不僅增強了程式撰寫能力，也加深對機械結構控制的理解。面對實務挑戰時，需要同時考慮軟體邏輯與硬體機構的整合，這對我未來的工程學習與專題開發都有很大幫助。未來我希望能將這些經驗延伸到更複雜的機械系統設計中，持續提升系統穩定性與自動化效率。 \n \n 影片標題:\xa0 國立虎尾科技大學 - 機械設計工程系 - cd2025 期末報告 - 41223226 - 程式展示 \n', 'tags': '', 'url': 'Final.html'}, {'title': 'Brython', 'text': '1 add to 100 \n  導入 brython 程式庫  \n \n \n \n \n  啟動 Brython  \n \n \n \n  導入 FileSaver 與 filereader  \n \n \n \n \n  導入 ace  \n \n \n \n \n \n \n  導入 gearUtils-0.9.js Cango 齒輪繪圖程式庫  \n \n \n \n \n \n \n  請注意, 這裡使用 Javascript 將 localStorage["kw_py_src1"] 中存在近端瀏覽器的程式碼, 由使用者決定存檔名稱 \n \n \n \n \n \n \n  add 1 to 100 開始  \n \n \n  add 1 to 100 結束 \n  editor1 開始  \n  用來顯示程式碼的 editor 區域  \n \n  以下的表單與按鈕與前面的 Javascript doSave 函式以及 FileSaver.min.js 互相配合  \n  存擋表單開始  \n Filename:  .py   \n  存擋表單結束  \n \n  執行與清除按鈕開始  \n Run   Output   清除輸出區 清除繪圖區 Reload \n  執行與清除按鈕結束  \n \n  程式執行 ouput 區  \n \n  Brython 程式執行的結果, 都以 brython_div1 作為切入位置  \n \n  editor1 結束   ##########################################  \n 從 1 累加到 100 part2: \n 1 add to 100 cango_three_gears BSnake AI Tetris \n  請注意, 這裡使用 Javascript 將 localStorage["kw_py_src2"] 中存在近端瀏覽器的程式碼, 由使用者決定存檔名稱 \n \n \n \n  add 1 to 100 part2 開始  \n \n \n  add 1 to 100 part2 結束 \n  editor2 開始  \n  用來顯示程式碼的 editor 區域  \n \n  以下的表單與按鈕與前面的 Javascript doSave 函式以及 FileSaver.min.js 互相配合  \n  存擋表單開始  \n Filename:  .py   \n  存擋表單結束  \n \n  執行與清除按鈕開始  \n Run   Output   清除輸出區 清除繪圖區 Reload \n  執行與清除按鈕結束  \n \n  程式執行 ouput 區  \n \n  Brython 程式執行的結果, 都以 brython_div1 作為切入位置  \n \n  editor2 結束  \n \n \n', 'tags': '', 'url': 'Brython.html'}]};